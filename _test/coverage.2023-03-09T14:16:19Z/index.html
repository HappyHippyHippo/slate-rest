
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>envelope: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/happyhippyhippo/slate-rest/envelope/envelope.go (100.0%)</option>
				
				<option value="file1">github.com/happyhippyhippo/slate-rest/envelope/list_report.go (100.0%)</option>
				
				<option value="file2">github.com/happyhippyhippo/slate-rest/envelope/status.go (100.0%)</option>
				
				<option value="file3">github.com/happyhippyhippo/slate-rest/envelope/status_error.go (100.0%)</option>
				
				<option value="file4">github.com/happyhippyhippo/slate-rest/envelope/status_error_list.go (100.0%)</option>
				
				<option value="file5">github.com/happyhippyhippo/slate-rest/envelopemw/errors.go (100.0%)</option>
				
				<option value="file6">github.com/happyhippyhippo/slate-rest/envelopemw/middleware.go (100.0%)</option>
				
				<option value="file7">github.com/happyhippyhippo/slate-rest/envelopemw/provider.go (100.0%)</option>
				
				<option value="file8">github.com/happyhippyhippo/slate-rest/errors.go (100.0%)</option>
				
				<option value="file9">github.com/happyhippyhippo/slate-rest/logmw/env.go (100.0%)</option>
				
				<option value="file10">github.com/happyhippyhippo/slate-rest/logmw/errors.go (100.0%)</option>
				
				<option value="file11">github.com/happyhippyhippo/slate-rest/logmw/middleware.go (100.0%)</option>
				
				<option value="file12">github.com/happyhippyhippo/slate-rest/logmw/provider.go (100.0%)</option>
				
				<option value="file13">github.com/happyhippyhippo/slate-rest/logmw/request_reader_decorator_json.go (100.0%)</option>
				
				<option value="file14">github.com/happyhippyhippo/slate-rest/logmw/request_reader_decorator_xml.go (100.0%)</option>
				
				<option value="file15">github.com/happyhippyhippo/slate-rest/logmw/request_reader_default.go (100.0%)</option>
				
				<option value="file16">github.com/happyhippyhippo/slate-rest/logmw/response_reader_decorator_json.go (100.0%)</option>
				
				<option value="file17">github.com/happyhippyhippo/slate-rest/logmw/response_reader_decorator_xml.go (100.0%)</option>
				
				<option value="file18">github.com/happyhippyhippo/slate-rest/logmw/response_reader_default.go (100.0%)</option>
				
				<option value="file19">github.com/happyhippyhippo/slate-rest/logmw/response_writer.go (100.0%)</option>
				
				<option value="file20">github.com/happyhippyhippo/slate-rest/process.go (100.0%)</option>
				
				<option value="file21">github.com/happyhippyhippo/slate-rest/provider.go (100.0%)</option>
				
				<option value="file22">github.com/happyhippyhippo/slate-rest/validation/errors.go (100.0%)</option>
				
				<option value="file23">github.com/happyhippyhippo/slate-rest/validation/parser.go (100.0%)</option>
				
				<option value="file24">github.com/happyhippyhippo/slate-rest/validation/provider.go (100.0%)</option>
				
				<option value="file25">github.com/happyhippyhippo/slate-rest/validation/validator.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package envelope

import (
        "encoding/xml"
)

// Envelope identifies the structure of a response structured format.
type Envelope struct {
        XMLName    xml.Name    `json:"-" xml:"envelope"`
        StatusCode int         `json:"-" xml:"-"`
        Status     *Status     `json:"status" xml:"status"`
        ListReport *ListReport `json:"report,omitempty" xml:"report,omitempty"`
        Data       interface{} `json:"data,omitempty" xml:"data,omitempty"`
}

// NewEnvelope instantiates a new response data envelope structure
func NewEnvelope(
        statusCode int,
        data interface{},
        listReport ...*ListReport,
) *Envelope <span class="cov10" title="10">{
        // initialize the envelope structure
        env := &amp;Envelope{
                StatusCode: statusCode,
                Status:     NewStatus(),
                ListReport: nil,
                Data:       data,
        }
        // assign the list report if given as argument
        if len(listReport) &gt; 0 &amp;&amp; listReport[0] != nil </span><span class="cov3" title="2">{
                env.ListReport = listReport[0]
        }</span>
        <span class="cov10" title="10">return env</span>
}

// GetStatusCode returned the stored enveloped response status code
func (s Envelope) GetStatusCode() int <span class="cov1" title="1">{
        return s.StatusCode
}</span>

// SetService assign the service identifier to all stored error codes
func (s *Envelope) SetService(
        val int,
) *Envelope <span class="cov1" title="1">{
        s.Status = s.Status.SetService(val)
        return s
}</span>

// SetEndpoint assign the endpoint identifier to all stored error codes
func (s *Envelope) SetEndpoint(
        val int,
) *Envelope <span class="cov5" title="3">{
        s.Status = s.Status.SetEndpoint(val)
        return s
}</span>

// SetListReport assign the list report to the envelope
func (s *Envelope) SetListReport(
        listReport *ListReport,
) *Envelope <span class="cov3" title="2">{
        s.ListReport = listReport
        return s
}</span>

// AddError add a new error to the response envelope instance
func (s *Envelope) AddError(
        e *StatusError,
) *Envelope <span class="cov10" title="10">{
        s.Status = s.Status.AddError(e)
        return s
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package envelope

import (
        "fmt"
)

// ListReport defines the structure of a response list report
// containing all the request information, but also the total amount of
// filtering records and links for the previous and next pages
type ListReport struct {
        Search string `json:"search" xml:"search"`
        Start  uint   `json:"start" xml:"start"`
        Count  uint   `json:"count" xml:"count"`
        Total  uint   `json:"total" xml:"total"`
        Prev   string `json:"prev" xml:"prev"`
        Next   string `json:"next" xml:"next"`
}

// NewListReport instantiates a new response list report by
// populating the prev and next link information regarding the given
// filtering information
func NewListReport(
        search string,
        start,
        count,
        total uint,
) *ListReport <span class="cov10" title="10">{
        // store the prev URL query parameters if the start value
        // is greater than zero
        prev := ""
        if start &gt; 0 </span><span class="cov9" title="9">{
                // discover the previous page starting value
                nstart := uint(0)
                if count &lt; start </span><span class="cov6" title="4">{
                        nstart = start - count
                }</span>
                // compose the URL prev page query parameters
                <span class="cov9" title="9">prev = fmt.Sprintf("?search=%s&amp;start=%d&amp;count=%d", search, nstart, count)</span>
        }
        // store the next URL query parameters if the total number of
        // record are greater than the current start plus the number of
        // presented records
        <span class="cov10" title="10">next := ""
        if start+count &lt; total </span><span class="cov8" title="7">{
                // compose the URL next page query parameters
                next = fmt.Sprintf("?search=%s&amp;start=%d&amp;count=%d", search, start+count, count)
        }</span>
        // return the list report instance reference
        <span class="cov10" title="10">return &amp;ListReport{
                Search: search,
                Start:  start,
                Count:  count,
                Total:  total,
                Prev:   prev,
                Next:   next,
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package envelope

// Status defines the structure to manipulate a
// response status information structure.
type Status struct {
        Success bool            `json:"success" xml:"success"`
        Errors  StatusErrorList `json:"error" xml:"error"`
}

// NewStatus instantiates a new request result status structure.
func NewStatus() *Status <span class="cov9" title="15">{
        return &amp;Status{
                Success: true,
                Errors:  StatusErrorList{},
        }
}</span>

// AddError append a new error to the status error list
func (s *Status) AddError(
        e *StatusError,
) *Status <span class="cov10" title="20">{
        s.Success = false
        s.Errors = append(s.Errors, e)
        return s
}</span>

// SetService assign a service code to all stored error.
func (s *Status) SetService(
        val int,
) *Status <span class="cov3" title="2">{
        for i := range s.Errors </span><span class="cov6" title="6">{
                s.Errors[i] = s.Errors[i].SetService(val)
        }</span>
        <span class="cov3" title="2">return s</span>
}

// SetEndpoint assign an endpoint code to all stored error.
func (s *Status) SetEndpoint(
        val int,
) *Status <span class="cov5" title="4">{
        for i := range s.Errors </span><span class="cov6" title="6">{
                s.Errors[i] = s.Errors[i].SetEndpoint(val)
        }</span>
        <span class="cov5" title="4">return s</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package envelope

import (
        "fmt"
        "strconv"
        "strings"
)

// StatusError defines the structure to manipulate an error structure
// that hold the information of an execution error and be assigned to the
// response status error list.
type StatusError struct {
        Service  int    `json:"-" xml:"-"`
        Endpoint int    `json:"-" xml:"-"`
        Param    int    `json:"-" xml:"-"`
        Error    string `json:"-" xml:"-"`
        Code     string `json:"code" xml:"code"`
        Message  string `json:"message" xml:"message"`
}

// NewStatusError instantiates a new error instance.
func NewStatusError(
        e any,
        msg string,
) *StatusError <span class="cov8" title="37">{
        return (&amp;StatusError{
                Error:   fmt.Sprintf("%v", e),
                Message: msg,
        }).compose()
}</span>

// SetService assigns a service code value to the error.
func (e *StatusError) SetService(
        val int,
) *StatusError <span class="cov6" title="15">{
        e.Service = val
        return e.compose()
}</span>

// SetEndpoint assigns an endpoint code value to the error.
func (e *StatusError) SetEndpoint(
        val int,
) *StatusError <span class="cov6" title="15">{
        e.Endpoint = val
        return e.compose()
}</span>

// SetParam assigns a parameter code value to the error.
func (e *StatusError) SetParam(
        param int,
) *StatusError <span class="cov3" title="4">{
        e.Param = param
        return e.compose()
}</span>

// SetError assigns a error code value to the error.
func (e *StatusError) SetError(
        err any,
) *StatusError <span class="cov4" title="6">{
        e.Error = fmt.Sprintf("%v", err)
        return e.compose()
}</span>

// SetMessage assigns a message to the error.
func (e *StatusError) SetMessage(
        msg string,
) *StatusError <span class="cov1" title="1">{
        e.Message = msg
        return e
}</span>

// GetCode retrieves the composed code of the error
func (e StatusError) GetCode() string <span class="cov1" title="1">{
        return e.Code
}</span>

// GetMessage retrieves the message associated to the error
func (e StatusError) GetMessage() string <span class="cov1" title="1">{
        return e.Message
}</span>

func (e *StatusError) compose() *StatusError <span class="cov10" title="77">{
        cb := strings.Builder{}
        // compose the service section of the code
        if e.Service != 0 </span><span class="cov8" title="30">{
                cb.WriteString(fmt.Sprintf("s:%d", e.Service))
        }</span>
        // compose the endpoint section of the code
        <span class="cov10" title="77">if e.Endpoint != 0 </span><span class="cov7" title="22">{
                if cb.Len() != 0 </span><span class="cov6" title="15">{
                        cb.WriteString(".")
                }</span>
                <span class="cov7" title="22">cb.WriteString(fmt.Sprintf("e:%d", e.Endpoint))</span>
        }
        // compose the param section of the code
        <span class="cov10" title="77">if e.Param != 0 </span><span class="cov5" title="7">{
                if cb.Len() != 0 </span><span class="cov4" title="6">{
                        cb.WriteString(".")
                }</span>
                <span class="cov5" title="7">cb.WriteString(fmt.Sprintf("p:%d", e.Param))</span>
        }
        // compose the error section of the code
        <span class="cov10" title="77">if e.Error != "" </span><span class="cov10" title="77">{
                if cb.Len() != 0 </span><span class="cov8" title="38">{
                        cb.WriteString(".")
                }</span>

                <span class="cov10" title="77">if i, err := strconv.Atoi(e.Error); err != nil </span><span class="cov3" title="4">{
                        cb.WriteString(e.Error)
                }</span> else<span class="cov9" title="73"> {
                        cb.WriteString(fmt.Sprintf("c:%d", i))
                }</span>
        }
        // assign the written code string to the error code structure parameter
        <span class="cov10" title="77">e.Code = cb.String()
        return e</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package envelope

import (
        "encoding/xml"
)

// StatusErrorList defines a type of data  that holds a list
// of error structures.
type StatusErrorList []*StatusError

// MarshalXML serialize the error list into a xml string
func (s StatusErrorList) MarshalXML(
        e *xml.Encoder,
        start xml.StartElement,
) error <span class="cov8" title="3">{
        // encode the list starting tag
        _ = e.EncodeToken(start)
        // iterate through all the stored error
        for _, v := range s </span><span class="cov10" title="4">{
                // create the iterated error starting tag name
                name := xml.Name{Space: "", Local: "error"}
                // encode the error instance tag with the code and message attributes
                _ = e.EncodeToken(xml.StartElement{
                        Name: name,
                        Attr: []xml.Attr{
                                {Name: xml.Name{Local: "code"}, Value: v.Code},
                                {Name: xml.Name{Local: "message"}, Value: v.Message},
                        },
                })
                // encode the terminating error tag
                _ = e.EncodeToken(xml.EndElement{Name: name})
        }</span>
        // encode the terminating list tag
        <span class="cov8" title="3">_ = e.EncodeToken(xml.EndElement{Name: start.Name})
        _ = e.Flush()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package envelopemw

import (
        "fmt"

        "github.com/happyhippyhippo/slate"
)

func errNilPointer(
        arg string,
        ctx ...map[string]interface{},
) error <span class="cov10" title="8">{
        return slate.NewErrorFrom(slate.ErrNilPointer, arg, ctx...)
}</span>

func errConversion(
        val interface{},
        t string,
        ctx ...map[string]interface{},
) error <span class="cov4" title="2">{
        return slate.NewErrorFrom(slate.ErrConversion, fmt.Sprintf("%v to %s", val, t), ctx...)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package envelopemw

import (
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/happyhippyhippo/slate-rest"
        "github.com/happyhippyhippo/slate-rest/envelope"
        "github.com/happyhippyhippo/slate/config"
        "github.com/happyhippyhippo/slate/log"
)

// MiddlewareGenerator @todo doc
type MiddlewareGenerator func(string) (rest.Middleware, error)

// NewMiddlewareGenerator returns a middleware generator function
// based on the application configuration. This middleware generator function
// should be called with the corresponding endpoint name, so it can generate
// the appropriate middleware function.
func NewMiddlewareGenerator(
        cfg config.IManager,
        logger log.ILog,
) (MiddlewareGenerator, error) <span class="cov10" title="43">{
        // check the config argument reference
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("cfg")
        }</span>
        // check the logger argument reference
        <span class="cov9" title="42">if logger == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("logger")
        }</span>
        // validate log level
        <span class="cov9" title="41">logLevel, ok := log.LevelMap[LogLevel]
        if !ok </span><span class="cov1" title="1">{
                logLevel = log.ERROR
        }</span>
        // retrieve the service id from the configuration
        <span class="cov9" title="41">service, e := cfg.Int(ServiceIDConfigPath, 0)
        if e != nil </span><span class="cov4" title="5">{
                _ = logger.Signal(LogChannel, logLevel, LogServiceErrorMessage, log.Context{"error": e})
                return nil, e
        }</span>
        // add a config observer for the service ID
        <span class="cov9" title="36">_ = cfg.AddObserver(ServiceIDConfigPath, func(old interface{}, new interface{}) </span><span class="cov4" title="5">{
                // new value type check for integer
                tnew, ok := new.(int)
                if !ok </span><span class="cov4" title="4">{
                        _ = logger.Signal(LogChannel, logLevel, LogServiceErrorMessage, log.Context{"value": new})
                        return
                }</span>
                <span class="cov1" title="1">service = tnew</span>
        })
        // retrieve the service REST accepted format list
        <span class="cov9" title="36">acceptedList, e := cfg.List(FormatAcceptListConfigPath)
        if e != nil </span><span class="cov4" title="4">{
                _ = logger.Signal(LogChannel, logLevel, LogAcceptListErrorMessage, log.Context{"error": e})
                return nil, e
        }</span>
        // parse the list retrieved from the configuration
        <span class="cov9" title="32">var accepted []string
        for _, v := range acceptedList </span><span class="cov9" title="32">{
                if tv, ok := v.(string); ok </span><span class="cov9" title="32">{
                        accepted = append(accepted, tv)
                }</span>
        }
        // add a config observer for the REST accepted format list
        <span class="cov9" title="32">_ = cfg.AddObserver(FormatAcceptListConfigPath, func(old interface{}, new interface{}) </span><span class="cov6" title="9">{
                accepted = []string{}
                // new value type check for an array
                tnew, ok := new.([]interface{})
                if !ok </span><span class="cov4" title="4">{
                        _ = logger.Signal(LogChannel, logLevel, LogAcceptListErrorMessage, log.Context{"list": new})
                        return
                }</span>
                // iterate through all the array elements
                <span class="cov4" title="5">for _, v := range tnew </span><span class="cov6" title="9">{
                        // type check for a string
                        if tv, ok := v.(string); !ok </span><span class="cov4" title="4">{
                                _ = logger.Signal(LogChannel, logLevel, LogAcceptListErrorMessage, log.Context{"value": v})
                        }</span> else<span class="cov4" title="5"> {
                                // add the iterated element to the accepted format list
                                accepted = append(accepted, tv)
                        }</span>
                }
        })
        // return the middleware generator
        <span class="cov9" title="32">return func(
                id string,
        ) (rest.Middleware, error) </span><span class="cov9" title="30">{
                // retrieve the endpoint id integer value from the configuration
                endpointIDConfigPath := fmt.Sprintf(EndpointIDConfigPathFormat, id)
                endpoint, e := cfg.Int(endpointIDConfigPath, 0)
                if e != nil </span><span class="cov4" title="4">{
                        _ = logger.Signal(LogChannel, logLevel, LogEndpointErrorMessage, log.Context{"error": e})
                        return nil, e
                }</span>
                // add a config observer for the endpoint id integer value
                <span class="cov8" title="26">_ = cfg.AddObserver(endpointIDConfigPath, func(old interface{}, new interface{}) </span><span class="cov4" title="5">{
                        // new value type check for integer
                        tnew, ok := new.(int)
                        if !ok </span><span class="cov4" title="4">{
                                _ = logger.Signal(LogChannel, logLevel, LogEndpointErrorMessage, log.Context{"value": new})
                                return
                        }</span>
                        <span class="cov1" title="1">endpoint = tnew</span>
                })
                // return the generated middleware function
                <span class="cov8" title="26">return func(
                        next gin.HandlerFunc,
                ) gin.HandlerFunc </span><span class="cov6" title="9">{
                        // return the middleware handler function
                        return func(
                                ctx *gin.Context,
                        ) </span><span class="cov6" title="9">{
                                // declare the result parsing method
                                parse := func(val interface{}) </span><span class="cov5" title="8">{
                                        var response *envelope.Envelope
                                        // type check the value to be enveloped
                                        switch v := val.(type) </span>{
                                        case *envelope.Envelope:<span class="cov1" title="1">
                                                // just set the result as the envelope reference
                                                response = v</span>
                                        case error:<span class="cov4" title="5">
                                                // set the result as a new envelope with an
                                                // internal server error with the given error as the
                                                // error message
                                                response =
                                                        envelope.NewEnvelope(http.StatusInternalServerError, nil).
                                                                AddError(envelope.NewStatusError(0, v.Error()))</span>
                                        default:<span class="cov2" title="2">
                                                // set the result as a new envelope with an
                                                // internal server error with a generic error message
                                                response =
                                                        envelope.NewEnvelope(http.StatusInternalServerError, nil).
                                                                AddError(envelope.NewStatusError(0, "internal server error"))</span>
                                        }
                                        // try to negotiate the response format with the defined
                                        // accepted format mime types giving the response envelope
                                        // as the content data of the response
                                        <span class="cov5" title="8">ctx.Negotiate(
                                                response.GetStatusCode(),
                                                gin.Negotiate{
                                                        Offered: accepted,
                                                        Data:    response.SetService(service).SetEndpoint(endpoint),
                                                },
                                        )</span>
                                }
                                // always try to fallback retrieve any error to be parsed
                                // and result in a proper envelope
                                <span class="cov6" title="9">defer func() </span><span class="cov6" title="9">{
                                        if e := recover(); e != nil </span><span class="cov2" title="2">{
                                                parse(e)
                                        }</span>
                                }()
                                // execute the middleware stored execution method
                                <span class="cov6" title="9">next(ctx)
                                // check if the response as been stored in the context to be
                                // correctly parsed
                                if response, exists := ctx.Get("response"); exists </span><span class="cov5" title="6">{
                                        parse(response)
                                }</span>
                        }
                }, nil
        }, nil
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package envelopemw

import (
        "github.com/happyhippyhippo/slate"
        "github.com/happyhippyhippo/slate-rest"
)

const (
        // ID defines the default id used to register
        // the application envelope middleware and related services.
        ID = rest.ID + ".envelope"
)

// Provider defines the default envelope provider to be used on
// the application initialization to register the file system adapter service.
type Provider struct{}

var _ slate.IProvider = &amp;Provider{}

// Register will add to the container a new file system adapter instance.
func (p Provider) Register(
        container ...slate.IContainer,
) error <span class="cov10" title="7">{
        // check container argument reference
        if len(container) == 0 || container[0] == nil </span><span class="cov4" title="2">{
                return errNilPointer("container")
        }</span>
        // register the envelope middleware generator
        <span class="cov8" title="5">_ = container[0].Service(ID, NewMiddlewareGenerator)
        return nil</span>
}

// Boot (no-op).
func (Provider) Boot(
        container ...slate.IContainer,
) error <span class="cov6" title="3">{
        // check container argument reference
        if len(container) == 0 || container[0] == nil </span><span class="cov4" title="2">{
                return errNilPointer("container")
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package rest

import (
        "fmt"

        "github.com/happyhippyhippo/slate"
)

func errNilPointer(
        arg string,
        ctx ...map[string]interface{},
) error <span class="cov10" title="9">{
        return slate.NewErrorFrom(slate.ErrNilPointer, arg, ctx...)
}</span>

func errConversion(
        val interface{},
        t string,
        ctx ...map[string]interface{},
) error <span class="cov6" title="4">{
        return slate.NewErrorFrom(slate.ErrConversion, fmt.Sprintf("%v to %s", val, t), ctx...)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package logmw

import (
        "strings"

        "github.com/happyhippyhippo/slate-rest"
        "github.com/happyhippyhippo/slate/env"
        "github.com/happyhippyhippo/slate/log"
)

const (
        // EnvID defines the slate.rest.log package base environment variable name.
        EnvID = rest.EnvID + "_LOG"
)

var (
        // RequestChannel defines the channel id to be used when
        // the log middleware sends the request logging signal to the logger
        // instance.
        RequestChannel = env.String(EnvID+"_REQUEST_CHANNEL", "rest")

        // RequestLevel defines the logging level to be used when
        // the log middleware sends the request logging signal to the logger
        // instance.
        RequestLevel = envToLogLevel(EnvID+"_REQUEST_LEVEL", log.DEBUG)

        // RequestMessage defines the request event logging message to
        // be used when the log middleware sends the logging signal to the logger
        // instance.
        RequestMessage = env.String(EnvID+"_REQUEST_MESSAGE", "Request")

        // ResponseChannel defines the channel id to be used when the
        // log middleware sends the response logging signal to the logger instance.
        ResponseChannel = env.String(EnvID+"_RESPONSE_CHANNEL", "rest")

        // ResponseLevel defines the logging level to be used when the
        // log middleware sends the response logging signal to the logger instance.
        ResponseLevel = envToLogLevel(EnvID+"_RESPONSE_LEVEL", log.INFO)

        // ResponseMessage defines the response event logging message
        // to be used when the log middleware sends the logging signal to the
        // logger instance.
        ResponseMessage = env.String(EnvID+"_RESPONSE_MESSAGE", "Response")

        // DecorateJSON flag that defines the decoration of the log entries
        // for JSON body content.
        DecorateJSON = env.Bool(EnvID+"_DECORATE_JSON", true)

        // DecorateXML flag that defines the decoration of the log entries
        // for XML body content.
        DecorateXML = env.Bool(EnvID+"_DECORATE_XML", false)
)

func envToLogLevel(ev string, def log.Level) log.Level <span class="cov10" title="15">{
        v, ok := log.LevelMap[strings.ToLower(ev)]
        if !ok </span><span class="cov4" title="3">{
                return def
        }</span>
        <span class="cov9" title="12">return v</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package logmw

import (
        "fmt"

        "github.com/happyhippyhippo/slate"
)

func errNilPointer(
        arg string,
        ctx ...map[string]interface{},
) error <span class="cov10" title="22">{
        return slate.NewErrorFrom(slate.ErrNilPointer, arg, ctx...)
}</span>

func errConversion(
        val interface{},
        t string,
        ctx ...map[string]interface{},
) error <span class="cov3" title="2">{
        return slate.NewErrorFrom(slate.ErrConversion, fmt.Sprintf("%v to %s", val, t), ctx...)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package logmw

import (
        "time"

        "github.com/gin-gonic/gin"
        "github.com/happyhippyhippo/slate-rest"
        "github.com/happyhippyhippo/slate/log"
)

// MiddlewareGenerator @todo doc
type MiddlewareGenerator func(statusCode int) rest.Middleware

// NewMiddlewareGenerator @todo doc
func NewMiddlewareGenerator(
        logger log.ILog,
        requestReader RequestReader,
        responseReader ResponseReader,
) (MiddlewareGenerator, error) <span class="cov10" title="6">{
        // check logger argument reference
        if logger == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("logger")
        }</span>
        // check request reader argument reference
        <span class="cov9" title="5">if requestReader == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("requestReader")
        }</span>
        // check response reader argument reference
        <span class="cov7" title="4">if responseReader == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("responseReader")
        }</span>
        // return the middleware generator function
        <span class="cov6" title="3">return func(
                statusCode int,
        ) rest.Middleware </span><span class="cov1" title="1">{
                // return the middleware method with the expected status code
                return func(
                        next gin.HandlerFunc,
                ) gin.HandlerFunc </span><span class="cov1" title="1">{
                        // return the middleware handler function
                        return func(
                                ctx *gin.Context,
                        ) </span><span class="cov1" title="1">{
                                // override the context writer
                                w, _ := newResponseWriter(ctx.Writer)
                                ctx.Writer = w
                                // obtain and log the request content
                                request, _ := requestReader(ctx)
                                _ = logger.Signal(
                                        RequestChannel,
                                        RequestLevel,
                                        RequestMessage,
                                        log.Context{
                                                "request": request,
                                        },
                                )
                                // execute the endpoint process and calculate the elapsed
                                // time of it
                                startTimestamp := time.Now().UnixMilli()
                                if next != nil </span><span class="cov1" title="1">{
                                        next(ctx)
                                }</span>
                                <span class="cov1" title="1">duration := time.Now().UnixMilli() - startTimestamp
                                // obtain and log the request, response and execution duration
                                response, _ := responseReader(ctx, w, statusCode)
                                _ = logger.Signal(
                                        ResponseChannel,
                                        ResponseLevel,
                                        ResponseMessage,
                                        log.Context{
                                                "request":  request,
                                                "response": response,
                                                "duration": duration,
                                        },
                                )</span>
                        }
                }
        }, nil
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package logmw

import (
        "github.com/happyhippyhippo/slate"
        "github.com/happyhippyhippo/slate-rest"
)

const (
        // ID defines the id to be used as the container
        // registration id of a logging middleware instance factory function.
        ID = rest.ID + ".logmw"

        // RequestReaderID @todo doc
        RequestReaderID = ID + ".reader.request"

        // ResponseReaderID @todo doc
        ResponseReaderID = ID + ".reader.response"
)

// Provider defines the slate.rest.log module service provider to be used on
// the application initialization to register the logging middleware service.
type Provider struct{}

var _ slate.IProvider = &amp;Provider{}

// Register will register the log middleware package instances in the
// application container
func (Provider) Register(
        container ...slate.IContainer,
) error <span class="cov10" title="10">{
        // check container argument reference
        if len(container) == 0 || container[0] == nil </span><span class="cov3" title="2">{
                return errNilPointer("container")
        }</span>
        // register the default request reader method
        <span class="cov9" title="8">_ = container[0].Service(RequestReaderID, func() RequestReader </span><span class="cov5" title="3">{
                requestReader := RequestReaderDefault
                if DecorateJSON </span><span class="cov5" title="3">{
                        requestReader, _ = NewRequestReaderDecoratorJSON(requestReader, nil)
                }</span>
                <span class="cov5" title="3">if DecorateXML </span><span class="cov1" title="1">{
                        requestReader, _ = NewRequestReaderDecoratorXML(requestReader, nil)
                }</span>
                <span class="cov5" title="3">return requestReader</span>
        })
        // register the default response reader method
        <span class="cov9" title="8">_ = container[0].Service(ResponseReaderID, func() ResponseReader </span><span class="cov3" title="2">{
                responseReader := ResponseReaderDefault
                if DecorateJSON </span><span class="cov3" title="2">{
                        responseReader, _ = NewResponseReaderDecoratorJSON(responseReader, nil)
                }</span>
                <span class="cov3" title="2">if DecorateXML </span><span class="cov1" title="1">{
                        responseReader, _ = NewResponseReaderDecoratorXML(responseReader, nil)
                }</span>
                <span class="cov3" title="2">return responseReader</span>
        })
        // register the logging middleware generator
        <span class="cov9" title="8">_ = container[0].Service(ID, NewMiddlewareGenerator)
        return nil</span>
}

// Boot will start the migration package
// If the auto migration is defined as true, ether by global variable or
// by environment variable, the migrator will automatically try to migrate
// to the last registered migration
func (p Provider) Boot(
        container ...slate.IContainer,
) error <span class="cov5" title="3">{
        // check container argument reference
        if len(container) == 0 || container[0] == nil </span><span class="cov3" title="2">{
                return errNilPointer("container")
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package logmw

import (
        "encoding/json"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/happyhippyhippo/slate/log"
)

// NewRequestReaderDecoratorJSON will instantiate a new request
// event context reader JSON decorator used to parse the request body as a JSON
// and add the parsed content into the logging data.
func NewRequestReaderDecoratorJSON(
        reader RequestReader,
        model interface{},
) (RequestReader, error) <span class="cov10" title="10">{
        // check the reader argument reference
        if reader == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("reader")
        }</span>
        // return the decorated request reader method
        <span class="cov9" title="9">return func(
                ctx *gin.Context,
        ) (log.Context, error) </span><span class="cov8" title="6">{
                // check the context argument reference
                if ctx == nil </span><span class="cov1" title="1">{
                        return nil, errNilPointer("ctx")
                }</span>
                // read the logging request data from the context
                <span class="cov7" title="5">data, e := reader(ctx)
                if e != nil </span><span class="cov1" title="1">{
                        return nil, e
                }</span>
                // try to unmarshall the request body content if the request
                // is in JSON format, and store it in the data map on the
                // bodyJson field
                <span class="cov6" title="4">contentType := strings.ToLower(ctx.Request.Header.Get("Content-Type"))
                if strings.HasPrefix(contentType, gin.MIMEJSON) </span><span class="cov3" title="2">{
                        if e = json.Unmarshal([]byte(data["body"].(string)), &amp;model); e == nil </span><span class="cov1" title="1">{
                                data["bodyJson"] = model
                        }</span>
                }
                // return the request information
                <span class="cov6" title="4">return data, nil</span>
        }, nil
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package logmw

import (
        "encoding/xml"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/happyhippyhippo/slate/log"
)

// NewRequestReaderDecoratorXML will instantiate a new request
// event context reader XML decorator used to parse the request body as an XML
// and add the parsed content into the logging data.
func NewRequestReaderDecoratorXML(
        reader RequestReader,
        model interface{},
) (RequestReader, error) <span class="cov10" title="9">{
        // check the reader argument reference
        if reader == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("reader")
        }</span>
        // return the decorated request reader method
        <span class="cov9" title="8">return func(
                ctx *gin.Context,
        ) (log.Context, error) </span><span class="cov8" title="7">{
                // check the context argument reference
                if ctx == nil </span><span class="cov1" title="1">{
                        return nil, errNilPointer("ctx")
                }</span>
                // read the logging request data from the context
                <span class="cov8" title="6">data, err := reader(ctx)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                // try to unmarshall the request body content if the request
                // is in XML format, and store it in the data map on the
                // bodyXml field
                <span class="cov7" title="5">contentType := strings.ToLower(ctx.Request.Header.Get("Content-Type"))
                if strings.HasPrefix(contentType, gin.MIMEXML) || strings.HasPrefix(contentType, gin.MIMEXML2) </span><span class="cov5" title="3">{
                        if err = xml.Unmarshal([]byte(data["body"].(string)), &amp;model); err == nil </span><span class="cov3" title="2">{
                                data["bodyXml"] = model
                        }</span>
                }
                // return the request information
                <span class="cov7" title="5">return data, nil</span>
        }, nil
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package logmw

import (
        "bytes"
        "io"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/happyhippyhippo/slate/log"
)

// RequestReaderDefault is the default function used to parse the request
// context information.
func RequestReaderDefault(
        ctx *gin.Context,
) (log.Context, error) <span class="cov10" title="2">{
        // check the context argument reference
        if ctx == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("ctx")
        }</span>
        // obtain the request parameters
        <span class="cov1" title="1">params := log.Context{}
        for p, v := range ctx.Request.URL.Query() </span><span class="cov10" title="2">{
                if len(v) == 1 </span><span class="cov1" title="1">{
                        params[p] = v[0]
                }</span> else<span class="cov1" title="1"> {
                        params[p] = v
                }</span>
        }
        // return the default request information
        <span class="cov1" title="1">return log.Context{
                "headers": requestHeaders(ctx.Request),
                "method":  ctx.Request.Method,
                "path":    ctx.Request.URL.Path,
                "params":  params,
                "body":    requestBody(ctx.Request),
        }, nil</span>
}

func requestHeaders(request *http.Request) log.Context <span class="cov1" title="1">{
        // try to flat single entry header fields
        headers := log.Context{}
        for index, header := range request.Header </span><span class="cov10" title="2">{
                if len(header) == 1 </span><span class="cov1" title="1">{
                        headers[index] = header[0]
                }</span> else<span class="cov1" title="1"> {
                        headers[index] = header
                }</span>
        }
        <span class="cov1" title="1">return headers</span>
}

func requestBody(request *http.Request) string <span class="cov1" title="1">{
        // obtain the request body (content destructible action)
        var bodyBytes []byte
        if request.Body != nil </span><span class="cov1" title="1">{
                bodyBytes, _ = io.ReadAll(request.Body)
        }</span>
        // reassign the request body with a memory buffer
        <span class="cov1" title="1">request.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
        return string(bodyBytes)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package logmw

import (
        "encoding/json"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/happyhippyhippo/slate/log"
)

// NewResponseReaderDecoratorJSON will instantiate a new response
// event context reader JSON decorator used to parse the response   body as
// a JSON and add the parsed content into the logging data.
func NewResponseReaderDecoratorJSON(
        reader ResponseReader,
        model interface{},
) (ResponseReader, error) <span class="cov10" title="12">{
        // check the reader argument reference
        if reader == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("reader")
        }</span>
        // return the decorated response reader method
        <span class="cov9" title="11">return func(
                ctx *gin.Context,
                writer responseWriter,
                statusCode int,
        ) (log.Context, error) </span><span class="cov8" title="9">{
                // check the context argument reference
                if ctx == nil </span><span class="cov1" title="1">{
                        return nil, errNilPointer("ctx")
                }</span>
                // check the writer argument reference
                <span class="cov8" title="8">if writer == nil </span><span class="cov1" title="1">{
                        return nil, errNilPointer("writer")
                }</span>
                // read the logging response data from the context
                <span class="cov8" title="7">data, err := reader(ctx, writer, statusCode)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                // check if there is content in the response body logging data
                // and try to unmarshall it if the response is in JSON to be logged
                // in the bodyJson field
                <span class="cov7" title="6">if body, ok := data["body"]; ok == true </span><span class="cov6" title="5">{
                        accept := strings.ToLower(ctx.Request.Header.Get("Accept"))
                        if accept == "*/*" || strings.Contains(accept, gin.MIMEJSON) </span><span class="cov4" title="3">{
                                if err = json.Unmarshal([]byte(body.(string)), &amp;model); err == nil </span><span class="cov3" title="2">{
                                        data["bodyJson"] = model
                                }</span>
                        }
                }
                // return the response information
                <span class="cov7" title="6">return data, nil</span>
        }, nil
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package logmw

import (
        "encoding/xml"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/happyhippyhippo/slate/log"
)

// NewResponseReaderDecoratorXML will instantiate a new response
// event context reader XML decorator used to parse the response body as an XML
// and add the parsed content into the logging data.
func NewResponseReaderDecoratorXML(
        reader ResponseReader,
        model interface{},
) (ResponseReader, error) <span class="cov10" title="11">{
        // check the reader argument reference
        if reader == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("reader")
        }</span>
        // return the decorated response reader method
        <span class="cov9" title="10">return func(
                ctx *gin.Context,
                writer responseWriter,
                statusCode int,
        ) (log.Context, error) </span><span class="cov9" title="9">{
                // check the context argument reference
                if ctx == nil </span><span class="cov1" title="1">{
                        return nil, errNilPointer("ctx")
                }</span>
                // check the writer argument reference
                <span class="cov8" title="8">if writer == nil </span><span class="cov1" title="1">{
                        return nil, errNilPointer("writer")
                }</span>
                // read the logging response data from the context
                <span class="cov8" title="7">data, err := reader(ctx, writer, statusCode)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                // check if there is content in the response body logging data
                // and try to unmarshall it if the response is in XML to be logged
                // in the bodyXml field
                <span class="cov7" title="6">if body, ok := data["body"]; ok == true </span><span class="cov7" title="5">{
                        accept := strings.ToLower(ctx.Request.Header.Get("Accept"))
                        if strings.Contains(accept, gin.MIMEXML) || strings.Contains(accept, gin.MIMEXML2) </span><span class="cov5" title="3">{
                                if err = xml.Unmarshal([]byte(body.(string)), &amp;model); err == nil </span><span class="cov3" title="2">{
                                        data["bodyXml"] = model
                                }</span>
                        }
                }
                // return the response information
                <span class="cov7" title="6">return data, nil</span>
        }, nil
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package logmw

import (
        "github.com/gin-gonic/gin"
        "github.com/happyhippyhippo/slate/log"
)

// ResponseReaderDefault @todo doc.
func ResponseReaderDefault(
        _ *gin.Context,
        writer responseWriter,
        statusCode int,
) (log.Context, error) <span class="cov8" title="3">{
        // check the writer argument reference
        if writer == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("writer")
        }</span>
        // obtain the response status code
        <span class="cov5" title="2">status := writer.Status()
        // store the default logging information
        data := log.Context{
                "status":  status,
                "headers": responseHeaders(writer),
        }
        // add the response body to the logging information if the
        // response status code differs from the expected
        if status != statusCode </span><span class="cov1" title="1">{
                data["body"] = string(writer.Body())
        }</span>
        // return the response logging information
        <span class="cov5" title="2">return data, nil</span>
}

func responseHeaders(
        response responseWriter,
) log.Context <span class="cov5" title="2">{
        // try to flat single entry header fields
        headers := log.Context{}
        for index, header := range response.Header() </span><span class="cov10" title="4">{
                if len(header) == 1 </span><span class="cov5" title="2">{
                        headers[index] = header[0]
                }</span> else<span class="cov5" title="2"> {
                        headers[index] = header
                }</span>
        }
        <span class="cov5" title="2">return headers</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package logmw

import (
        "bytes"

        "github.com/gin-gonic/gin"
)

type responseWriter interface {
        gin.ResponseWriter
        Body() []byte
}

type writer struct {
        gin.ResponseWriter
        body *bytes.Buffer
}

var _ gin.ResponseWriter = &amp;writer{}

func newResponseWriter(
        w gin.ResponseWriter,
) (responseWriter, error) <span class="cov10" title="19">{
        // check the writer argument reference
        if w == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("writer")
        }</span>
        // return a new decorated writer instance
        <span class="cov9" title="18">return &amp;writer{
                ResponseWriter: w,
                body:           &amp;bytes.Buffer{},
        }, nil</span>
}

// Write executes the writing the desired bytes into the underlying writer
// and storing them in the internal buffer.
func (w writer) Write(
        b []byte,
) (int, error) <span class="cov1" title="1">{
        // write the content in the local body copy and
        // in the default response writer
        w.body.Write(b)
        return w.ResponseWriter.Write(b)
}</span>

// Body will retrieve the stored bytes given on the previous calls
// to the Write method.
func (w writer) Body() []byte <span class="cov3" title="2">{
        // get the local copy of the response body
        return w.body.Bytes()
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package rest

import (
        "fmt"

        "github.com/happyhippyhippo/slate/config"
        "github.com/happyhippyhippo/slate/log"
        "github.com/happyhippyhippo/slate/watchdog"
)

// Process defines the REST watchdog process instance.
type Process struct {
        *watchdog.Process
}

var _ watchdog.IProcess = &amp;Process{}

type processConfig struct {
        Watchdog string
        Port     int
        Log      struct {
                Level   string
                Channel string
                Message struct {
                        Start string
                        Error string
                        End   string
                }
        }
}

// NewProcess will try to instantiate an REST watchdog process.
func NewProcess(
        cfgManager config.IManager,
        logger log.ILog,
        engine Engine,
) (*Process, error) <span class="cov10" title="14">{
        // check the config reference
        if cfgManager == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("cfgManager")
        }</span>
        // check the log reference
        <span class="cov9" title="13">if logger == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("logger")
        }</span>
        // check the engine reference
        <span class="cov9" title="12">if engine == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("engine")
        }</span>
        // get service watchdog process configuration
        <span class="cov9" title="11">cfg, e := cfgManager.Config(ConfigPath, config.Config{})
        if e != nil </span><span class="cov3" title="2">{
                return nil, e
        }</span>
        // parse the retrieved configuration
        <span class="cov8" title="9">wc := processConfig{
                Watchdog: WatchdogName,
                Port:     Port,
                Log: struct {
                        Level   string
                        Channel string
                        Message struct {
                                Start string
                                Error string
                                End   string
                        }
                }{
                        Level:   LogLevel,
                        Channel: LogChannel,
                        Message: struct {
                                Start string
                                Error string
                                End   string
                        }{
                                Start: LogStartMessage,
                                Error: LogErrorMessage,
                                End:   LogEndMessage,
                        },
                },
        }
        _, e = cfg.Populate("", &amp;wc)
        if e != nil </span><span class="cov1" title="1">{
                return nil, e
        }</span>
        // validate the logging level read from config
        <span class="cov8" title="8">logLevel, ok := log.LevelMap[wc.Log.Level]
        if !ok </span><span class="cov1" title="1">{
                return nil, errConversion(wc.Log.Level, "log.Level")
        }</span>
        // generate the watchdog process instance
        <span class="cov7" title="7">proc, _ := watchdog.NewProcess(wc.Watchdog, func() error </span><span class="cov5" title="4">{
                _ = logger.Signal(wc.Log.Channel, logLevel, wc.Log.Message.Start, log.Context{"port": wc.Port})
                if e = engine.Run(fmt.Sprintf(":%d", wc.Port)); e != nil </span><span class="cov3" title="2">{
                        _ = logger.Signal(wc.Log.Channel, log.FATAL, wc.Log.Message.Error, log.Context{"error": e.Error()})
                        return e
                }</span>
                <span class="cov3" title="2">_ = logger.Signal(wc.Log.Channel, logLevel, wc.Log.Message.End)
                return nil</span>
        })
        // return a locally defines instance of the watchdog process
        <span class="cov7" title="7">return &amp;Process{
                Process: proc,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package rest

import (
        "github.com/gin-gonic/gin"
        "github.com/happyhippyhippo/slate"
        "github.com/happyhippyhippo/slate/watchdog"
)

const (
        // ID defines a base id of all other rest
        // package instances registered in the application container.
        ID = slate.ID + ".rest"

        // EngineID defines the id to be used as the
        // container registration id of the rest engine instance.
        EngineID = ID + ".engine"

        // ProcessID defines the id to be used as the
        // container registration id of the rest watchdog process.
        ProcessID = ID + ".process"

        // EndpointRegisterTag defines the tag to be used as the
        // identification of a controller's registration instance.
        EndpointRegisterTag = ID + ".register"
)

// Provider defines the REST services provider instance.
type Provider struct{}

var _ slate.IProvider = &amp;Provider{}

// Register will register the REST section instances in the
// application container.
func (p Provider) Register(
        container ...slate.IContainer,
) error <span class="cov10" title="17">{
        // check container argument reference
        if len(container) == 0 || container[0] == nil </span><span class="cov3" title="2">{
                return errNilPointer("container")
        }</span>
        // add REST engine
        <span class="cov9" title="15">_ = container[0].Service(EngineID, func() Engine </span><span class="cov7" title="7">{
                return gin.New()
        }</span>)
        // add REST watchdog process instance
        <span class="cov9" title="15">_ = container[0].Service(ProcessID, NewProcess, watchdog.ProcessTag)
        return nil</span>
}

// Boot will start the REST engine with the defined controllers.
func (p Provider) Boot(
        container ...slate.IContainer,
) error <span class="cov7" title="9">{
        // check container argument reference
        if len(container) == 0 || container[0] == nil </span><span class="cov3" title="2">{
                return errNilPointer("container")
        }</span>
        // retrieve the REST engine
        <span class="cov7" title="7">engine, e := p.getEngine(container[0])
        if e != nil </span><span class="cov3" title="2">{
                return e
        }</span>
        // retrieve the controller's registration instances
        <span class="cov6" title="5">registers, e := p.getRegisters(container[0])
        if e != nil </span><span class="cov1" title="1">{
                return e
        }</span>
        // run the registration process of all retrieved registers
        <span class="cov5" title="4">for _, reg := range registers </span><span class="cov6" title="5">{
                if e := reg.Reg(engine); e != nil </span><span class="cov1" title="1">{
                        return e
                }</span>
        }
        <span class="cov4" title="3">return nil</span>
}

func (Provider) getEngine(
        container slate.IContainer,
) (Engine, error) <span class="cov8" title="10">{
        // retrieve the loader entry
        entry, e := container.Get(EngineID)
        if e != nil </span><span class="cov1" title="1">{
                return nil, e
        }</span>
        // validate the retrieved entry type
        <span class="cov7" title="9">instance, ok := entry.(Engine)
        if !ok </span><span class="cov1" title="1">{
                return nil, errConversion(entry, "rest.Engine")
        }</span>
        <span class="cov7" title="8">return instance, nil</span>
}

func (Provider) getRegisters(
        container slate.IContainer,
) ([]IEndpointRegister, error) <span class="cov6" title="5">{
        // retrieve the strategies entries
        entries, e := container.Tag(EndpointRegisterTag)
        if e != nil </span><span class="cov1" title="1">{
                return nil, e
        }</span>
        // type check the retrieved strategies
        <span class="cov5" title="4">var registers []IEndpointRegister
        for _, entry := range entries </span><span class="cov6" title="5">{
                if instance, ok := entry.(IEndpointRegister); ok </span><span class="cov6" title="5">{
                        registers = append(registers, instance)
                }</span>
        }
        <span class="cov5" title="4">return registers, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package validation

import (
        "fmt"

        "github.com/happyhippyhippo/slate"
)

var (
        // ErrTranslatorNotFound @todo doc
        ErrTranslatorNotFound = fmt.Errorf("translator not found")
)

func errNilPointer(
        arg string,
        ctx ...map[string]interface{},
) error <span class="cov10" title="13">{
        return slate.NewErrorFrom(slate.ErrNilPointer, arg, ctx...)
}</span>

func errConversion(
        val interface{},
        t string,
        ctx ...map[string]interface{},
) error <span class="cov3" title="2">{
        return slate.NewErrorFrom(slate.ErrConversion, fmt.Sprintf("%v to %s", val, t), ctx...)
}</span>

func errTranslatorNotFound(
        translator string,
        ctx ...map[string]interface{},
) error <span class="cov6" title="5">{
        return slate.NewErrorFrom(ErrTranslatorNotFound, translator, ctx...)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package validation

import (
        "net/http"
        "reflect"
        "strconv"

        ut "github.com/go-playground/universal-translator"
        "github.com/go-playground/validator/v10"
        "github.com/happyhippyhippo/slate-rest/envelope"
)

// IParser defines the interface to an error parsing object used to
// convert a validation error into an envelope error
type IParser interface {
        Parse(val interface{}, errs validator.ValidationErrors) (*envelope.Envelope, error)
        AddError(e string, code int)
}

type parser struct {
        mapper     map[string]int
        translator ut.Translator
}

var _ IParser = &amp;parser{}

// NewParser instantiate a new validation parser instance
func NewParser(
        translator ut.Translator,
) (IParser, error) <span class="cov10" title="13">{
        if translator == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("translator")
        }</span>

        <span class="cov9" title="12">return &amp;parser{
                mapper: map[string]int{
                        "eqcsfield":     1,
                        "eqfield":       2,
                        "fieldcontains": 3,
                        "fieldexcludes": 4,
                        "gtcsfield":     5,
                        "gtecsfield":    6,
                        "gtefield":      7,
                        "gtfield":       8,
                        "ltcsfield":     9,
                        "ltecsfield":    10,
                        "ltefield":      11,
                        "ltfield":       12,
                        "necsfield":     13,
                        "nefield":       14,

                        "cidr":             15,
                        "cidrv4":           16,
                        "cidrv6":           17,
                        "datauri":          18,
                        "fqdn":             19,
                        "hostname":         20,
                        "hostname_port":    21,
                        "hostname_rfc1123": 22,
                        "ip":               23,
                        "ip4_addr":         24,
                        "ip6_addr":         25,
                        "ip_addr":          26,
                        "ipv4":             27,
                        "ipv6":             28,
                        "mac":              29,
                        "tcp4_addr":        30,
                        "tcp6_addr":        31,
                        "tcp_addr":         32,
                        "udp4_addr":        33,
                        "udp6_addr":        34,
                        "udp_addr":         35,
                        "unix_addr":        36,
                        "uri":              37,
                        "url":              38,
                        "url_encoded":      39,
                        "urn_rfc2141":      40,

                        "alpha":           41,
                        "alphanum":        42,
                        "alphanumunicode": 43,
                        "alphaunicode":    44,
                        "ascii":           45,
                        "contains":        46,
                        "containsany":     47,
                        "containsrune":    48,
                        "endswith":        49,
                        "lowercase":       50,
                        "multibyte":       51,
                        "number":          52,
                        "numeric":         53,
                        "printascii":      54,
                        "startswith":      55,
                        "uppercase":       56,

                        "base64":          57,
                        "base64url":       58,
                        "btc_addr":        59,
                        "btc_addr_bech32": 60,
                        "datetime":        61,
                        "e164":            62,
                        "email":           63,
                        "eth_addr":        64,
                        "hexadecimal":     65,
                        "hexcolor":        66,
                        "hsl":             67,
                        "hsla":            68,
                        "html":            69,
                        "html_encoded":    70,
                        "isbn":            71,
                        "isbn10":          72,
                        "isbn13":          73,
                        "json":            74,
                        "latitude":        75,
                        "longitude":       76,
                        "rgb":             77,
                        "rgba":            78,
                        "ssn":             79,
                        "uuid":            80,
                        "uuid3":           81,
                        "uuid3_rfc4122":   82,
                        "uuid4":           83,
                        "uuid4_rfc4122":   84,
                        "uuid5":           85,
                        "uuid5_rfc4122":   86,
                        "uuid_rfc4122":    87,

                        "eq":  88,
                        "gt":  89,
                        "gte": 90,
                        "lt":  91,
                        "lte": 92,
                        "ne":  93,

                        "dir":                  94,
                        "excludes":             95,
                        "excludesall":          96,
                        "excludesrune":         97,
                        "file":                 98,
                        "isdefault":            99,
                        "len":                  100,
                        "max":                  101,
                        "min":                  102,
                        "oneof":                103,
                        "required":             104,
                        "required_if":          105,
                        "required_unless":      106,
                        "required_with":        107,
                        "required_with_all":    108,
                        "required_without":     109,
                        "required_without_all": 110,
                        "excluded_with":        111,
                        "excluded_with_all":    112,
                        "excluded_without":     113,
                        "excluded_without_all": 114,
                        "unique":               115,
                },
                translator: translator,
        }, nil</span>
}

// Parse method that will convert the list of validation error into
// an envelope struct to be used as the endpoint response.
func (p parser) Parse(
        val interface{},
        errs validator.ValidationErrors,
) (*envelope.Envelope, error) <span class="cov8" title="9">{
        if val == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("value")
        }</span>

        <span class="cov8" title="8">if errs == nil || len(errs) == 0 </span><span class="cov3" title="2">{
                return nil, nil
        }</span>

        <span class="cov7" title="6">resp := envelope.NewEnvelope(http.StatusBadRequest, nil, nil)
        for _, e := range errs </span><span class="cov7" title="6">{
                parsed, result := p.convert(val, e)
                if result != nil </span><span class="cov3" title="2">{
                        return nil, result
                }</span>
                <span class="cov5" title="4">resp = resp.AddError(parsed)</span>
        }

        <span class="cov5" title="4">return resp, nil</span>
}

// AddError will add a validation mapped error to code value.
func (p *parser) AddError(
        e string,
        code int,
) <span class="cov1" title="1">{
        p.mapper[e] = code
}</span>

func (p parser) convert(
        value interface{},
        e validator.FieldError,
) (*envelope.StatusError, error) <span class="cov7" title="6">{
        if e == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("error")
        }</span>

        <span class="cov6" title="5">typeof := reflect.TypeOf(value)
        field, _ := typeof.FieldByName(e.StructField())
        iparam := 0
        if param, ok := field.Tag.Lookup("vparam"); ok </span><span class="cov3" title="2">{
                var err error
                if iparam, err = strconv.Atoi(param); err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov5" title="4">return envelope.NewStatusError(p.mapper[e.Tag()], e.Translate(p.translator)).SetParam(iparam), nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package validation

import (
        "github.com/go-playground/locales/en"
        ut "github.com/go-playground/universal-translator"
        "github.com/go-playground/validator/v10"
        translations "github.com/go-playground/validator/v10/translations/en"
        "github.com/happyhippyhippo/slate"
        "github.com/happyhippyhippo/slate-rest"
)

const (
        // ID defines the id to be used
        // as the container registration id of a validation.
        ID = rest.ID + ".validation"

        // UniversalTranslatorID defines the id to be used
        // as the container registration id of a universal translator.
        UniversalTranslatorID = ID + ".universal_translator"

        // TranslatorID defines the id to be used
        // as the container registration id of a translator.
        TranslatorID = ID + ".translator"

        // ParserID defines the id to be used
        // as the container registration id of an error parser instance.
        ParserID = ID + ".parser"
)

// Provider @todo doc
type Provider struct{}

var _ slate.IProvider = &amp;Provider{}

// Register will register the validation package instances in the
// application container
func (p Provider) Register(
        container ...slate.IContainer,
) error <span class="cov10" title="13">{
        // check container argument reference
        if len(container) == 0 || container[0] == nil </span><span class="cov3" title="2">{
                return errNilPointer("container")
        }</span>
        // register a universal translator
        <span class="cov9" title="11">_ = container[0].Service(UniversalTranslatorID, func() *ut.UniversalTranslator </span><span class="cov8" title="8">{
                lang := en.New()
                return ut.New(lang, lang)
        }</span>)
        // register a translator instance of the defined default locale
        <span class="cov9" title="11">_ = container[0].Service(TranslatorID, func(universalTranslator *ut.UniversalTranslator) (ut.Translator, error) </span><span class="cov7" title="7">{
                translator, found := universalTranslator.GetTranslator(Locale)
                if found == false </span><span class="cov4" title="3">{
                        return nil, errTranslatorNotFound(Locale)
                }</span>
                <span class="cov5" title="4">return translator, nil</span>
        })
        // register a validation error parser
        <span class="cov9" title="11">_ = container[0].Service(ParserID, NewParser)
        // register a validation method service
        _ = container[0].Service(ID, func(translator ut.Translator, parser IParser) (Validator, error) </span><span class="cov1" title="1">{
                validate := validator.New()
                _ = translations.RegisterDefaultTranslations(validate, translator)
                return NewValidator(validate, parser)
        }</span>)
        <span class="cov9" title="11">return nil</span>
}

// Boot will start the validation package
func (p Provider) Boot(
        container ...slate.IContainer,
) error <span class="cov4" title="3">{
        // check container argument reference
        if len(container) == 0 || container[0] == nil </span><span class="cov3" title="2">{
                return errNilPointer("container")
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package validation

import (
        "github.com/go-playground/validator/v10"
        "github.com/happyhippyhippo/slate-rest/envelope"
)

// Validator is a function type used to define a calling interface of
// function responsible to validate an instance of a structure and return
// an initialized response envelope with the founded error
type Validator func(val interface{}) (*envelope.Envelope, error)

// NewValidator instantiates a new validation function
func NewValidator(
        validate *validator.Validate,
        parser IParser,
) (Validator, error) <span class="cov10" title="8">{
        // check validate argument reference
        if validate == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("validate")
        }</span>
        // check parser argument reference
        <span class="cov9" title="7">if parser == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("parser")
        }</span>
        // return the validation method instance
        <span class="cov8" title="6">return func(value interface{}) (*envelope.Envelope, error) </span><span class="cov7" title="4">{
                // check the value argument reference
                if value == nil </span><span class="cov1" title="1">{
                        return nil, errNilPointer("value")
                }</span>
                // validate the given structure
                <span class="cov5" title="3">if errs := validate.Struct(value); errs != nil </span><span class="cov4" title="2">{
                        // compose the response envelope with the parsed validation error
                        return parser.Parse(value, errs.(validator.ValidationErrors))
                }</span>
                <span class="cov1" title="1">return nil, nil</span>
        }, nil
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
